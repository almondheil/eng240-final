## Starting to code

Now, we'll start creating the code behind our steganography method.

Start off by creating a new Python file called `encode.py`.

??? question "Where can I write and run Python code?"

    === "CoCalc"

        CoCalc can work if you took ENG-240 and you still have access to your Grinnell account.

        Access it at <https://cocalc.com/projects>.

    === "Google Colab"

        If you have a Google account, you can use Colab and create a notebook there.

        You can find it at <https://colab.research.google.com>.

        Colab uses a different format than we're used to from CoCalc, where rather than having a code file you write code in cells.
        There is a [tutorial on Colab](https://colab.research.google.com/notebooks/basic_features_overview.ipynb) if you are interested.

    === "Your computer"
        
        If you have an easy time installing and running new software, you can install Python directly.

        You can start at <https://www.python.org/downloads/>.

## Scaffolding the program

We'll start off by planning out the steps our progam must take, from the lowest level upwards.

!!! failure "TODO: DO I DEFINE ENCODE AND DECODE EVER?"

First, we'll define a function with almost no code and just comments saying what we need to do.

``` py title="encode.py"
def encode_message():
    # Ask the user what their secret message will be

    # Ask the user what file to use as a cover text

    # Encode the length of the secret message as a binary code, then convert it to whitespace

    # Place the encoded length at the end of the first file line

    # For every letter in the secret message, do these steps.
    for TODO_FILL_IN_LOOP:
        # Use the translation table to convert it to a binary code (0s and 1s)

        # Turn that binary code into whitespace

        # Place the generated whitespace at the end of the line

    # Ask the user what file to save the result to

# run the program when the file is run
encode_message()
```

!!! warning

    This code will not yet be able to run, it's just a skeleton of our program.

Now, let's go through and start filling in things below those comments. I'll make changes in small batches, and highlight which lines changed.

First, we can use the `input()` function to ask for user input where it is relevant.

``` py title="encode.py - user input" hl_lines="3 6 21"
def encode_message():
    # Ask the user what their secret message will be
    secret_message = input('Secret message? ')

    # Ask the user what file to use as a cover text
    cover_text = input('Cover text file? ')

    # Make sure the file is long enough for the message

    # Encode the length of the secret message as a binary code, then convert it to whitespace

    # Place the encoded length at the end of the first file line

    # For every letter in the secret message, do these steps.
    for TODO_FILL_IN_LOOP:
        # Use the translation table to convert it to a binary code (0s and 1s)

        # Turn that binary code into whitespace

        # Place the generated whitespace at the end of the line

    # Ask the user what file to save the result to
    output_file = input('Output text file? ')

# run the program when the file is run
encode_message()
```

Next, we can add logic to open the files the user specifies and handle errors.

``` py title="encode.py - file opening" hl_lines="7-8 24-25"
def encode_message():
    # Ask the user what their secret message will be
    secret_message = input('Secret message? ')

    # Ask the user what file to use as a cover text
    cover_text = input('Cover text file? ')
    with open(cover_text, 'r') as input:
        lines = input.readlines()

    # Make sure the file is long enough for the message

    # Encode the length of the secret message as a binary code, then convert it to whitespace

    # Place the encoded length at the end of the first file line

    # For every letter in the secret message, do these steps.
    for TODO_FILL_IN_LOOP:
        # Use the translation table to convert it to a binary code (0s and 1s)

        # Turn that binary code into whitespace

        # Place the generated whitespace at the end of the line

    # Ask the user what file to save the result to
    output_file = input('Output text file? ')
    with open(output_file, 'w') as output:
        output.writelines(lines)

# run the program when the file is run
encode_message()
```

!!! note

    We should technically handle errors if the file fails to open for any reason,
    but I don't want to add the extra complexity. We never handled these errors in
    our code from class, either.

## Making characters into whitespace

First, let's work on the process of turning characters into whitespace.

### Characters to binary codes

To do that, we need to establish a **mapping** from characters to binary codes.

!!! question

    What set of characters should we choose to make our mapping?

We want to keep the number of characters in our mapping low, because having more will make the binary codes longer and easier to detect.

Because of that, we'll stick to the lowercase letters of the alphabet.

There are 26 of those, but because we're using binary code we can fit 32 (2^5) characters in that amount of space.
Here's what we'll go with for this tutorial:

- Lowercase letters, `a`-`z`.
- Punctuation: `,` `.` `!` `?` `-` 
- Spaces

!!! question

    How can we represent our mapping in Python?

We can code our this by creating a dictionary, which is a Python data structure that maps keys to values. Here's a small example.

```py title="Example Dictionary"
example = {
    'key1': 'value1',
    'key2': 'value2',
    'key3': 'value3'
}

a = example['key2']
# -> 'value2'
```

If we do the same with our 32 characters, we can count up in binary to make their codes.

When we finish, it looks like this:

```py title="encode.py - letter_to_code dictionary"
letter_to_code = {
    'a': '0',      // letters
    'b': '1',
    'c': '10',
    'd': '11',
    'e': '100',
    'f': '101',
    'g': '110',
    'h': '111',
    'i': '1000',
    'j': '1001',
    'k': '1010',
    'l': '1011',
    'm': '1100',
    'n': '1101',
    'o': '1110',
    'p': '1111',
    'q': '10000',
    'r': '10001',
    's': '10010',
    't': '10011',
    'u': '10100',
    'v': '10101',
    'w': '10110',
    'x': '10111',
    'y': '11000',
    'z': '11001',
    ',': '11100',  // punctuation
    '.': '11011',
    '!': '11101',
    '?': '11110',
    '-': '11111',
    ' ': '11010'   // space
}

// (the rest of your file below)
```

### Binary codes to whitespace

## Message length header

First, let's work on writing the message length as a header to the file.

To do that, first we need to turn the message length into a binary 

!!! failure

    TODO: THIS IS WHERE WE ARE GONNA DO BINARY, JUST USE PYTHON BUILTIN??? RIGHT??? OR DOES HE EXPECT DIFFERENT???

    TODO: AND YOU WILL ALSO DEVELOP THE "ADD TO END OF LINE HERE" AND IT WILL DEAL WITH SPACES AND TABS AND NEWLINES AND \r-S

## Invididual character encoding

!!! failure

    TODO: I SHOULD MAKE IT SO THAT, IF THERE IS SPACE AT THE END OF THE LINE, WE DELETE THAT. RSTRIP MORE TEXT.

    TODO: HAVE THEM FILL IN THE LOOP

## Dealing with input problems

!!! failure

    TODO: THIS IS WHERE I WILL ASK THEM TO CHECK THE FILE LENGTH AND CHECK THE MESSAGE HAS VALID CHARACTERS.

## Running the code

Now that we've written this code file, it should be ready to run!

To do that, we'll need a cover text. You can choose any text file, but I'll also provide one.

!!! note "File downloads"

    === "Cover file"

        This is an excerpt from [Lighthouses: Their history and romance](https://www.gutenberg.org/ebooks/76041) by William John Hardy on Project Gutenberg.

        [Download `lighthouses.txt`](static/lighthouses.txt){:download="lighthouses.txt"}

    === "Code file"

        I hope you were following along, but I'll provide my finished code for this part if you need it.

        [Download `encode.py`](static/encode.py){:download="encode.py"}

Save the file to the same directory as your code, and then run it with `python encode.py`.

Here's what to respond to each prompt:

1. Secret message: A short message of your choice, using the allowed characters
2. Cover text: `lighthouses.txt`, or the name of the text file you choose.
3. Output file: `hidden.txt`

When it's done, you can open `hidden.txt`. It'll look just like before, unless you select the lines and reveal the extra spaces.
